package fr.upmc.flyingduke.domain.dao;

import com.google.appengine.api.datastore.DatastoreService;
import com.google.appengine.api.datastore.DatastoreServiceFactory;
import com.google.appengine.api.datastore.Entity;
import com.google.appengine.api.datastore.EntityNotFoundException;
import com.google.appengine.api.datastore.Key;
import com.google.appengine.api.datastore.KeyFactory;
import com.google.appengine.api.datastore.PreparedQuery;
import com.google.appengine.api.datastore.PreparedQuery.TooManyResultsException;
import com.google.appengine.api.datastore.Query;
import com.google.appengine.api.datastore.Query.Filter;
import com.google.appengine.api.datastore.Query.FilterOperator;
import com.google.appengine.api.datastore.Query.FilterPredicate;
import com.google.appengine.api.users.User;

import fr.upmc.flyingduke.domain.FDUser;
import fr.upmc.flyingduke.exceptions.ExistingUserException;

public class FDUserDao {
	
	public static final String FD_USER_KIND = "FD_USER_KIND";
	private static final String FIRST_NAME = "FIRST_NAME";
	private static final String LAST_NAME = "LAST_NAME";
	private static final String GOOGLE_USER = "GOOGLE_USER";
	private static final String WALLET = "WALLET";

	private final static DatastoreService datastore = DatastoreServiceFactory.getDatastoreService();
	private final static Key ancestor = KeyFactory.createKey(FD_USER_KIND, "USER_ANCESTOR");

	/**
	 * Retrieves the fduser in base for the given id;
	 * @param id the id must be created through the datastore
	 * @return the fduser in base for the given id
	 */
	public static FDUser get(long id) throws EntityNotFoundException {

		// get Entity
		Key key = KeyFactory.createKey(ancestor, FD_USER_KIND, id);
		Entity entity = datastore.get(key);

		return fdUserFromEntity(entity);		
	}

	/**
	 * Creates a new user in the base. The google datastore will
	 * generate an id for the user.
	 * @param user the google user must be unique.
	 * @throws ExistingUserException 
	 */
	public static FDUser create(User googleuser) throws ExistingUserException {
		FDUser fduser = getFromGoogleUser(googleuser);
		if (fduser != null) {
			throw new ExistingUserException();
		}
		// create entity
		Entity entity = new Entity(FD_USER_KIND, ancestor);
		entity.setProperty(GOOGLE_USER, googleuser);
		
		// put in store, will generate a key
		datastore.put(entity);
		System.out.println("create " + entity);

		// return the User with the assigned id
		return fdUserFromEntity(entity);
	}

	/**
	 * Updates the fields of a specific user. checks id the user is in base.
	 * @param user the user to save
	 * @return the id generated by the datastore
	 * @throws EntityNotFoundException thrown if the user is not in the base.
	 * Users must be created from FDUserDao.create()
	 */
	public static void update(FDUser user) throws EntityNotFoundException {
		System.out.println("put " + user.toString());

		// check if user is in base
		Key key = KeyFactory.createKey(ancestor, FD_USER_KIND, user.getId());
		Entity entity = datastore.get(key);

		// update properties
		entity.setProperty(FIRST_NAME, user.getFirstName());
		entity.setProperty(LAST_NAME, user.getLastName());
		entity.setProperty(GOOGLE_USER, user.getGoogleuser());
		entity.setProperty(WALLET, user.getWallet());

		// update in base
		datastore.put(entity);
	}

	/**
	 *  Retrieves the (unique) fduser matching the given google account.
	 *  This method crashes if multiple fdusers are in base for the google account.
	 * @param googleuser the parameter for the search
	 * @return the (unique) fduser matching the given google account or null if the user is not in base
	 */
	public static FDUser getFromGoogleUser(User googleuser) {
		Filter userFilter = 
				new FilterPredicate(GOOGLE_USER, FilterOperator.EQUAL, googleuser);

		Query query = new Query(FD_USER_KIND).setFilter(userFilter).setAncestor(ancestor);
		PreparedQuery pq = datastore.prepare(query);
		Entity entity = null;
		try {
			 entity = pq.asSingleEntity();
		} catch (TooManyResultsException exception) {
			for (Entity e: pq.asIterable()) {
				//datastore.delete(e.getKey());
				System.out.println("clean db to restore google accounts constraints" + e);
			}
			throw exception; 
		}
		
		if (entity == null)
			return null;
		
		return fdUserFromEntity(entity);

	}
	
	/**
	 * Deletes the user for the given google account
	 * @param googleuser
	 */
	public static void deleteUser(User googleuser) {
		Filter userFilter = 
				new FilterPredicate(GOOGLE_USER, FilterOperator.EQUAL, googleuser);

		Query query = new Query(FD_USER_KIND).setFilter(userFilter).setAncestor(ancestor);
		PreparedQuery pq = datastore.prepare(query);

		for (Entity entity: pq.asIterable()) {
			System.out.println("==> delete " + entity.toString());
			datastore.delete(entity.getKey());
		}

	}

	private static FDUser fdUserFromEntity(Entity entity) {
		
		Object firstName = entity.getProperty(FIRST_NAME);
		Object lastName = entity.getProperty(LAST_NAME);
		Object googleUser = entity.getProperty(GOOGLE_USER);
		Object wallet  = entity.getProperty(WALLET);

		// build user
		FDUser fdUser = new FDUser(entity.getKey().getId());
		if (firstName != null)
			fdUser.setFirstName((String) firstName);
		if (lastName != null)
			fdUser.setLastName((String) lastName);
		if (googleUser != null)
			fdUser.setGoogleuser((User) googleUser); 
		if (wallet != null)
			fdUser.setWallet(((Long) wallet).intValue());
		return fdUser;
	}
}
